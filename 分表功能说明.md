# 分表功能使用说明

## 功能概述
本系统已经为`BuildController.java`添加了完整的分表功能支持。分表功能可以帮助您将大表拆分成多个小表，提高查询性能和数据管理效率。

## 配置方式

### 1. 配置文件方式（推荐）
在`src/main/resources/sharding-config.properties`文件中配置：

```properties
# 启用分表的表名列表（逗号分隔）
sharding.tables=user_log,order_record,system_history

# 用户日志表分表配置
user_log.sharding.field=createTime
user_log.sharding.strategy=time

# 订单记录表分表配置  
order_record.sharding.field=orderId
order_record.sharding.strategy=hash

# 系统历史表分表配置
system_history.sharding.field=recordDate
system_history.sharding.strategy=time
```

### 2. 自动检测方式
系统会自动检测表名包含以下关键字的表启用分表：
- `log` - 日志表
- `order` - 订单表  
- `record` - 记录表
- `history` - 历史表

## 分表策略

### 1. 时间分表 (time)
- **适用场景**: 时间字段作为分表键
- **分表规则**: 按月份分表，格式为 `tablename_yyyyMM`
- **示例**: `user_log_202401`, `user_log_202402`

### 2. 哈希分表 (hash) 
- **适用场景**: ID字段或字符串字段作为分表键
- **分表规则**: 对分表键值取哈希后取模，默认分10张表
- **示例**: `order_record_00`, `order_record_01`, ..., `order_record_09`

### 3. 范围分表 (range)
- **适用场景**: 数值字段作为分表键
- **分表规则**: 按数值范围分表，每10000条记录一张表
- **示例**: `data_record_00` (0-9999), `data_record_01` (10000-19999)

## 生成的Controller方法

启用分表后，Controller中会生成以下增强方法：

### 1. 查询方法
```java
@RequestMapping("/loadDataList")
public ResponseVO loadDataList(UserLogParam query) {
    if (query.getCreateTime() != null) {
        // 单表查询
        return getSuccessResponseVO(userLogService.findListByPage(query));
    } else {
        // 多表查询
        return getSuccessResponseVO(userLogService.findListByPageWithSharding(query));
    }
}
```

### 2. 新增方法
```java
@RequestMapping("/add")
public ResponseVO add(UserLog bean) {
    // 分表新增逻辑
    String tableName = getShardingTableName(bean.getCreateTime());
    return getSuccessResponseVO(userLogService.addWithSharding(bean, tableName));
}
```

### 3. 删除方法
```java
@RequestMapping("/deleteByParam")
public ResponseVO deleteByParam(UserLogParam param) {
    if (param.getCreateTime() != null) {
        // 单表删除
        String tableName = getShardingTableName(param.getCreateTime());
        return getSuccessResponseVO(userLogService.deleteByParamWithSharding(param, tableName));
    } else {
        // 多表删除
        return getSuccessResponseVO(userLogService.deleteByParamWithAllSharding(param));
    }
}
```

## 工具类说明

### ShardingUtils
提供分表相关的工具方法：
- `getTableName()` - 根据分表策略获取表名
- `getAllTableNames()` - 获取所有分表名称
- `getShardingCount()` - 获取分表数量

### ShardingConfigUtils  
提供分表配置读取功能：
- `isShardingTable()` - 检查表是否需要分表
- `getShardingField()` - 获取分表字段
- `getShardingStrategy()` - 获取分表策略

## 注意事项

1. **分表字段**: 确保配置的分表字段在表中存在
2. **索引设计**: 分表字段建议添加索引以提高查询性能
3. **跨表查询**: 没有分表字段值的查询会执行多表查询，性能相对较低
4. **数据迁移**: 启用分表前需要考虑现有数据的迁移策略

## 扩展说明

如需添加新的分表策略，可以在`ShardingUtils`类中扩展相应的方法：

```java
case "custom":
    return getCustomTableName(baseTableName, shardingValue);
```

系统设计具有良好的扩展性，可以根据具体业务需求定制分表逻辑。
